import { g as Bt, s as Nt, w as Lt } from "../core-DifZDvrd.js";
import { b as zt, e as rn, j as en, j as tn, p as nn, k as an } from "../core-DifZDvrd.js";
var gr = (() => {
  var W = typeof document < "u" && document.currentScript ? document.currentScript.src : void 0;
  return function(Y = {}) {
    var zr;
    var u = Y, mr, J;
    u.ready = new Promise((r, e) => {
      mr = r, J = e;
    });
    var yr = Object.assign({}, u), br = typeof window == "object", wr = typeof Bun < "u", re = typeof ((zr = globalThis.WebAssembly) == null ? void 0 : zr.instantiate) == "function", Q = typeof importScripts == "function";
    typeof process == "object" && typeof process.versions == "object" && process.versions.node;
    var A = "";
    function ee(r) {
      return u.locateFile ? u.locateFile(r, A) : A + r;
    }
    var sr;
    (br || Q || wr) && (Q ? A = self.location.href : typeof document < "u" && document.currentScript && (A = document.currentScript.src), W && (A = W), A.startsWith("blob:") ? A = "" : A = A.substr(0, A.replace(/[?#].*/, "").lastIndexOf("/") + 1), Q && (sr = (r) => {
      var e = new XMLHttpRequest();
      return e.open("GET", r, !1), e.responseType = "arraybuffer", e.send(null), new Uint8Array(e.response);
    })), u.print || console.log.bind(console);
    var B = u.printErr || console.error.bind(console);
    Object.assign(u, yr), yr = null, u.arguments && u.arguments, u.thisProgram && u.thisProgram, u.quit && u.quit;
    var N;
    u.wasmBinary && (N = u.wasmBinary);
    var z, Tr = !1, k, h, x, L, D, d, $r, Ar;
    function Er() {
      var r = z.buffer;
      u.HEAP8 = k = new Int8Array(r), u.HEAP16 = x = new Int16Array(r), u.HEAPU8 = h = new Uint8Array(r), u.HEAPU16 = L = new Uint16Array(r), u.HEAP32 = D = new Int32Array(r), u.HEAPU32 = d = new Uint32Array(r), u.HEAPF32 = $r = new Float32Array(r), u.HEAPF64 = Ar = new Float64Array(r);
    }
    var Rr = [], Cr = [], Pr = [];
    function te() {
      if (u.preRun)
        for (typeof u.preRun == "function" && (u.preRun = [u.preRun]); u.preRun.length; )
          ie(u.preRun.shift());
      ur(Rr);
    }
    function ne() {
      ur(Cr);
    }
    function ae() {
      if (u.postRun)
        for (typeof u.postRun == "function" && (u.postRun = [u.postRun]); u.postRun.length; )
          se(u.postRun.shift());
      ur(Pr);
    }
    function ie(r) {
      Rr.unshift(r);
    }
    function oe(r) {
      Cr.unshift(r);
    }
    function se(r) {
      Pr.unshift(r);
    }
    var U = 0, X = null;
    function ue(r) {
      var e;
      U++, (e = u.monitorRunDependencies) === null || e === void 0 || e.call(u, U);
    }
    function fe(r) {
      var e;
      if (U--, (e = u.monitorRunDependencies) === null || e === void 0 || e.call(u, U), U == 0 && X) {
        var t = X;
        X = null, t();
      }
    }
    function Fr(r) {
      var e;
      (e = u.onAbort) === null || e === void 0 || e.call(u, r), r = "Aborted(" + r + ")", B(r), Tr = !0, r += ". Build with -sASSERTIONS for more info.";
      var t = new WebAssembly.RuntimeError(r);
      throw J(t), t;
    }
    var ce = "data:application/octet-stream;base64,", Wr = (r) => r.startsWith(ce), O;
    O = "zxing_writer.wasm", Wr(O) || (O = ee(O));
    function kr(r) {
      if (r == O && N)
        return new Uint8Array(N);
      if (sr)
        return sr(r);
      throw "both async and sync fetching of the wasm failed";
    }
    function ve(r) {
      return !N && (br || Q || wr || re) && typeof fetch == "function" ? fetch(r, {
        credentials: "same-origin"
      }).then((e) => {
        if (!e.ok)
          throw `failed to load wasm binary file at '${r}'`;
        return e.arrayBuffer();
      }).catch(() => kr(r)) : Promise.resolve().then(() => kr(r));
    }
    function Sr(r, e, t) {
      return ve(r).then((n) => WebAssembly.instantiate(n, e)).then(t, (n) => {
        B(`failed to asynchronously prepare wasm: ${n}`), Fr(n);
      });
    }
    function le(r, e, t, n) {
      return !r && typeof WebAssembly.instantiateStreaming == "function" && !Wr(e) && typeof fetch == "function" ? fetch(e, {
        credentials: "same-origin"
      }).then((a) => {
        var i = WebAssembly.instantiateStreaming(a, t);
        return i.then(n, function(s) {
          return B(`wasm streaming compile failed: ${s}`), B("falling back to ArrayBuffer instantiation"), Sr(e, t, n);
        });
      }) : Sr(e, t, n);
    }
    function de() {
      var r = {
        a: Ft
      };
      function e(n, a) {
        return p = n.exports, z = p.R, Er(), Br = p.V, oe(p.S), fe(), p;
      }
      ue();
      function t(n) {
        e(n.instance);
      }
      if (u.instantiateWasm)
        try {
          return u.instantiateWasm(r, e);
        } catch (n) {
          B(`Module.instantiateWasm callback failed with error: ${n}`), J(n);
        }
      return le(N, O, r, t).catch(J), {};
    }
    var ur = (r) => {
      for (; r.length > 0; )
        r.shift()(u);
    };
    u.noExitRuntime;
    var Ur = [], _e = (r) => {
      var e = new fr(r);
      return e.get_caught() || e.set_caught(!0), e.set_rethrown(!1), Ur.push(e), Kr(e.excPtr), e.get_exception_ptr();
    }, M = 0, pe = () => {
      w(0, 0);
      var r = Ur.pop();
      Gr(r.excPtr), M = 0;
    };
    class fr {
      constructor(e) {
        this.excPtr = e, this.ptr = e - 24;
      }
      set_type(e) {
        d[this.ptr + 4 >> 2] = e;
      }
      get_type() {
        return d[this.ptr + 4 >> 2];
      }
      set_destructor(e) {
        d[this.ptr + 8 >> 2] = e;
      }
      get_destructor() {
        return d[this.ptr + 8 >> 2];
      }
      set_caught(e) {
        e = e ? 1 : 0, k[this.ptr + 12] = e;
      }
      get_caught() {
        return k[this.ptr + 12] != 0;
      }
      set_rethrown(e) {
        e = e ? 1 : 0, k[this.ptr + 13] = e;
      }
      get_rethrown() {
        return k[this.ptr + 13] != 0;
      }
      init(e, t) {
        this.set_adjusted_ptr(0), this.set_type(e), this.set_destructor(t);
      }
      set_adjusted_ptr(e) {
        d[this.ptr + 16 >> 2] = e;
      }
      get_adjusted_ptr() {
        return d[this.ptr + 16 >> 2];
      }
      get_exception_ptr() {
        var e = Jr(this.get_type());
        if (e)
          return d[this.excPtr >> 2];
        var t = this.get_adjusted_ptr();
        return t !== 0 ? t : this.excPtr;
      }
    }
    var he = (r) => {
      throw M || (M = r), M;
    }, cr = (r) => {
      var e = M;
      if (!e)
        return q(0), 0;
      var t = new fr(e);
      t.set_adjusted_ptr(e);
      var n = t.get_type();
      if (!n)
        return q(0), e;
      for (var a in r) {
        var i = r[a];
        if (i === 0 || i === n)
          break;
        var s = t.ptr + 16;
        if (Yr(i, n, s))
          return q(i), e;
      }
      return q(n), e;
    }, ge = () => cr([]), me = (r) => cr([r]), ye = (r, e) => cr([r, e]), be = (r, e, t) => {
      var n = new fr(r);
      throw n.init(e, t), M = r, M;
    }, rr = {}, vr = (r) => {
      for (; r.length; ) {
        var e = r.pop(), t = r.pop();
        t(e);
      }
    };
    function er(r) {
      return this.fromWireType(d[r >> 2]);
    }
    var V = {}, I = {}, tr = {}, Mr, Ir = (r) => {
      throw new Mr(r);
    }, jr = (r, e, t) => {
      r.forEach(function(o) {
        tr[o] = e;
      });
      function n(o) {
        var f = t(o);
        f.length !== r.length && Ir("Mismatched type converter count");
        for (var c = 0; c < r.length; ++c)
          E(r[c], f[c]);
      }
      var a = new Array(e.length), i = [], s = 0;
      e.forEach((o, f) => {
        I.hasOwnProperty(o) ? a[f] = I[o] : (i.push(o), V.hasOwnProperty(o) || (V[o] = []), V[o].push(() => {
          a[f] = I[o], ++s, s === i.length && n(a);
        }));
      }), i.length === 0 && n(a);
    }, we = (r) => {
      var e = rr[r];
      delete rr[r];
      var t = e.rawConstructor, n = e.rawDestructor, a = e.fields, i = a.map((s) => s.getterReturnType).concat(a.map((s) => s.setterArgumentType));
      jr([r], i, (s) => {
        var o = {};
        return a.forEach((f, c) => {
          var v = f.fieldName, l = s[c], _ = f.getter, m = f.getterContext, S = s[c + a.length], G = f.setter, R = f.setterContext;
          o[v] = {
            read: (K) => l.fromWireType(_(m, K)),
            write: (K, hr) => {
              var or = [];
              G(R, K, S.toWireType(or, hr)), vr(or);
            }
          };
        }), [{
          name: e.name,
          fromWireType: (f) => {
            var c = {};
            for (var v in o)
              c[v] = o[v].read(f);
            return n(f), c;
          },
          toWireType: (f, c) => {
            for (var v in o)
              if (!(v in c))
                throw new TypeError(`Missing field: "${v}"`);
            var l = t();
            for (v in o)
              o[v].write(l, c[v]);
            return f !== null && f.push(n, l), l;
          },
          argPackAdvance: C,
          readValueFromPointer: er,
          destructorFunction: n
        }];
      });
    }, Te = (r, e, t, n, a) => {
    }, $e = () => {
      for (var r = new Array(256), e = 0; e < 256; ++e)
        r[e] = String.fromCharCode(e);
      xr = r;
    }, xr, g = (r) => {
      for (var e = "", t = r; h[t]; )
        e += xr[h[t++]];
      return e;
    }, Dr, y = (r) => {
      throw new Dr(r);
    };
    function Ae(r, e) {
      let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var n = e.name;
      if (r || y(`type "${n}" must have a positive integer typeid pointer`), I.hasOwnProperty(r)) {
        if (t.ignoreDuplicateRegistrations)
          return;
        y(`Cannot register type '${n}' twice`);
      }
      if (I[r] = e, delete tr[r], V.hasOwnProperty(r)) {
        var a = V[r];
        delete V[r], a.forEach((i) => i());
      }
    }
    function E(r, e) {
      let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (!("argPackAdvance" in e))
        throw new TypeError("registerType registeredInstance requires argPackAdvance");
      return Ae(r, e, t);
    }
    var C = 8, Ee = (r, e, t, n) => {
      e = g(e), E(r, {
        name: e,
        fromWireType: function(a) {
          return !!a;
        },
        toWireType: function(a, i) {
          return i ? t : n;
        },
        argPackAdvance: C,
        readValueFromPointer: function(a) {
          return this.fromWireType(h[a]);
        },
        destructorFunction: null
      });
    }, lr = [], P = [], dr = (r) => {
      r > 9 && --P[r + 1] === 0 && (P[r] = void 0, lr.push(r));
    }, Re = () => P.length / 2 - 5 - lr.length, Ce = () => {
      P.push(0, 1, void 0, 1, null, 1, !0, 1, !1, 1), u.count_emval_handles = Re;
    }, j = {
      toValue: (r) => (r || y("Cannot use deleted val. handle = " + r), P[r]),
      toHandle: (r) => {
        switch (r) {
          case void 0:
            return 2;
          case null:
            return 4;
          case !0:
            return 6;
          case !1:
            return 8;
          default: {
            const e = lr.pop() || P.length;
            return P[e] = r, P[e + 1] = 1, e;
          }
        }
      }
    }, Pe = {
      name: "emscripten::val",
      fromWireType: (r) => {
        var e = j.toValue(r);
        return dr(r), e;
      },
      toWireType: (r, e) => j.toHandle(e),
      argPackAdvance: C,
      readValueFromPointer: er,
      destructorFunction: null
    }, Fe = (r) => E(r, Pe), We = (r, e, t) => {
      if (r[e].overloadTable === void 0) {
        var n = r[e];
        r[e] = function() {
          for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++)
            i[s] = arguments[s];
          return r[e].overloadTable.hasOwnProperty(i.length) || y(`Function '${t}' called with an invalid number of arguments (${i.length}) - expects one of (${r[e].overloadTable})!`), r[e].overloadTable[i.length].apply(this, i);
        }, r[e].overloadTable = [], r[e].overloadTable[n.argCount] = n;
      }
    }, Or = (r, e, t) => {
      u.hasOwnProperty(r) ? ((t === void 0 || u[r].overloadTable !== void 0 && u[r].overloadTable[t] !== void 0) && y(`Cannot register public name '${r}' twice`), We(u, r, r), u.hasOwnProperty(t) && y(`Cannot register multiple overloads of a function with the same number of arguments (${t})!`), u[r].overloadTable[t] = e) : (u[r] = e, t !== void 0 && (u[r].numArguments = t));
    }, ke = (r, e, t) => {
      switch (e) {
        case 1:
          return t ? function(n) {
            return this.fromWireType(k[n]);
          } : function(n) {
            return this.fromWireType(h[n]);
          };
        case 2:
          return t ? function(n) {
            return this.fromWireType(x[n >> 1]);
          } : function(n) {
            return this.fromWireType(L[n >> 1]);
          };
        case 4:
          return t ? function(n) {
            return this.fromWireType(D[n >> 2]);
          } : function(n) {
            return this.fromWireType(d[n >> 2]);
          };
        default:
          throw new TypeError(`invalid integer width (${e}): ${r}`);
      }
    }, Se = (r, e, t, n) => {
      e = g(e);
      function a() {
      }
      a.values = {}, E(r, {
        name: e,
        constructor: a,
        fromWireType: function(i) {
          return this.constructor.values[i];
        },
        toWireType: (i, s) => s.value,
        argPackAdvance: C,
        readValueFromPointer: ke(e, t, n),
        destructorFunction: null
      }), Or(e, a);
    }, nr = (r, e) => Object.defineProperty(e, "name", {
      value: r
    }), Vr = (r) => {
      var e = qr(r), t = g(e);
      return F(e), t;
    }, Hr = (r, e) => {
      var t = I[r];
      return t === void 0 && y(`${e} has unknown type ${Vr(r)}`), t;
    }, Ue = (r, e, t) => {
      var n = Hr(r, "enum");
      e = g(e);
      var a = n.constructor, i = Object.create(n.constructor.prototype, {
        value: {
          value: t
        },
        constructor: {
          value: nr(`${n.name}_${e}`, function() {
          })
        }
      });
      a.values[t] = i, a[e] = i;
    }, Me = (r, e) => {
      switch (e) {
        case 4:
          return function(t) {
            return this.fromWireType($r[t >> 2]);
          };
        case 8:
          return function(t) {
            return this.fromWireType(Ar[t >> 3]);
          };
        default:
          throw new TypeError(`invalid float width (${e}): ${r}`);
      }
    }, Ie = (r, e, t) => {
      e = g(e), E(r, {
        name: e,
        fromWireType: (n) => n,
        toWireType: (n, a) => a,
        argPackAdvance: C,
        readValueFromPointer: Me(e, t),
        destructorFunction: null
      });
    };
    function je(r) {
      for (var e = 1; e < r.length; ++e)
        if (r[e] !== null && r[e].destructorFunction === void 0)
          return !0;
      return !1;
    }
    function xe(r, e, t, n, a, i) {
      var s = e.length;
      s < 2 && y("argTypes array size mismatch! Must at least get return value and 'this' types!");
      var o = e[1] !== null && t !== null, f = je(e), c = e[0].name !== "void", v = s - 2, l = new Array(v), _ = [], m = [], S = function() {
        arguments.length !== v && y(`function ${r} called with ${arguments.length} arguments, expected ${v}`), m.length = 0;
        var G;
        _.length = o ? 2 : 1, _[0] = a, o && (G = e[1].toWireType(m, this), _[1] = G);
        for (var R = 0; R < v; ++R)
          l[R] = e[R + 2].toWireType(m, R < 0 || arguments.length <= R ? void 0 : arguments[R]), _.push(l[R]);
        var K = n(..._);
        function hr(or) {
          if (f)
            vr(m);
          else
            for (var H = o ? 1 : 2; H < e.length; H++) {
              var Ht = H === 1 ? G : l[H - 2];
              e[H].destructorFunction !== null && e[H].destructorFunction(Ht);
            }
          if (c)
            return e[0].fromWireType(or);
        }
        return hr(K);
      };
      return nr(r, S);
    }
    var De = (r, e) => {
      for (var t = [], n = 0; n < r; n++)
        t.push(d[e + n * 4 >> 2]);
      return t;
    }, Oe = (r, e, t) => {
      u.hasOwnProperty(r) || Ir("Replacing nonexistent public symbol"), u[r].overloadTable !== void 0 && t !== void 0 ? u[r].overloadTable[t] = e : (u[r] = e, u[r].argCount = t);
    }, Ve = (r, e, t) => {
      var n = u["dynCall_" + r];
      return n(e, ...t);
    }, ar = [], Br, b = (r) => {
      var e = ar[r];
      return e || (r >= ar.length && (ar.length = r + 1), ar[r] = e = Br.get(r)), e;
    }, He = function(r, e) {
      let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      if (r.includes("j"))
        return Ve(r, e, t);
      var n = b(e)(...t);
      return n;
    }, Be = (r, e) => function() {
      for (var t = arguments.length, n = new Array(t), a = 0; a < t; a++)
        n[a] = arguments[a];
      return He(r, e, n);
    }, Z = (r, e) => {
      r = g(r);
      function t() {
        return r.includes("j") ? Be(r, e) : b(e);
      }
      var n = t();
      return typeof n != "function" && y(`unknown function pointer with signature ${r}: ${e}`), n;
    }, Ne = (r, e) => {
      var t = nr(e, function(n) {
        this.name = e, this.message = n;
        var a = new Error(n).stack;
        a !== void 0 && (this.stack = this.toString() + `
` + a.replace(/^Error(:[^\n]*)?\n/, ""));
      });
      return t.prototype = Object.create(r.prototype), t.prototype.constructor = t, t.prototype.toString = function() {
        return this.message === void 0 ? this.name : `${this.name}: ${this.message}`;
      }, t;
    }, Nr, Le = (r, e) => {
      var t = [], n = {};
      function a(i) {
        if (!n[i] && !I[i]) {
          if (tr[i]) {
            tr[i].forEach(a);
            return;
          }
          t.push(i), n[i] = !0;
        }
      }
      throw e.forEach(a), new Nr(`${r}: ` + t.map(Vr).join([", "]));
    }, Xe = (r) => {
      r = r.trim();
      const e = r.indexOf("(");
      return e !== -1 ? r.substr(0, e) : r;
    }, Ze = (r, e, t, n, a, i, s) => {
      var o = De(e, t);
      r = g(r), r = Xe(r), a = Z(n, a), Or(r, function() {
        Le(`Cannot call ${r} due to unbound types`, o);
      }, e - 1), jr([], o, (f) => {
        var c = [f[0], null].concat(f.slice(1));
        return Oe(r, xe(r, c, null, a, i), e - 1), [];
      });
    }, qe = (r, e, t) => {
      switch (e) {
        case 1:
          return t ? (n) => k[n] : (n) => h[n];
        case 2:
          return t ? (n) => x[n >> 1] : (n) => L[n >> 1];
        case 4:
          return t ? (n) => D[n >> 2] : (n) => d[n >> 2];
        default:
          throw new TypeError(`invalid integer width (${e}): ${r}`);
      }
    }, Ge = (r, e, t, n, a) => {
      e = g(e);
      var i = (v) => v;
      if (n === 0) {
        var s = 32 - 8 * t;
        i = (v) => v << s >>> s;
      }
      var o = e.includes("unsigned"), f = (v, l) => {
      }, c;
      o ? c = function(v, l) {
        return f(l, this.name), l >>> 0;
      } : c = function(v, l) {
        return f(l, this.name), l;
      }, E(r, {
        name: e,
        fromWireType: i,
        toWireType: c,
        argPackAdvance: C,
        readValueFromPointer: qe(e, t, n !== 0),
        destructorFunction: null
      });
    }, Ke = (r, e, t) => {
      var n = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], a = n[e];
      function i(s) {
        var o = d[s >> 2], f = d[s + 4 >> 2];
        return new a(k.buffer, f, o);
      }
      t = g(t), E(r, {
        name: t,
        fromWireType: i,
        argPackAdvance: C,
        readValueFromPointer: i
      }, {
        ignoreDuplicateRegistrations: !0
      });
    }, Ye = (r, e, t, n) => {
      if (!(n > 0))
        return 0;
      for (var a = t, i = t + n - 1, s = 0; s < r.length; ++s) {
        var o = r.charCodeAt(s);
        if (o >= 55296 && o <= 57343) {
          var f = r.charCodeAt(++s);
          o = 65536 + ((o & 1023) << 10) | f & 1023;
        }
        if (o <= 127) {
          if (t >= i)
            break;
          e[t++] = o;
        } else if (o <= 2047) {
          if (t + 1 >= i)
            break;
          e[t++] = 192 | o >> 6, e[t++] = 128 | o & 63;
        } else if (o <= 65535) {
          if (t + 2 >= i)
            break;
          e[t++] = 224 | o >> 12, e[t++] = 128 | o >> 6 & 63, e[t++] = 128 | o & 63;
        } else {
          if (t + 3 >= i)
            break;
          e[t++] = 240 | o >> 18, e[t++] = 128 | o >> 12 & 63, e[t++] = 128 | o >> 6 & 63, e[t++] = 128 | o & 63;
        }
      }
      return e[t] = 0, t - a;
    }, Je = (r, e, t) => Ye(r, h, e, t), Qe = (r) => {
      for (var e = 0, t = 0; t < r.length; ++t) {
        var n = r.charCodeAt(t);
        n <= 127 ? e++ : n <= 2047 ? e += 2 : n >= 55296 && n <= 57343 ? (e += 4, ++t) : e += 3;
      }
      return e;
    }, Lr = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0, ze = (r, e, t) => {
      for (var n = e + t, a = e; r[a] && !(a >= n); )
        ++a;
      if (a - e > 16 && r.buffer && Lr)
        return Lr.decode(r.subarray(e, a));
      for (var i = ""; e < a; ) {
        var s = r[e++];
        if (!(s & 128)) {
          i += String.fromCharCode(s);
          continue;
        }
        var o = r[e++] & 63;
        if ((s & 224) == 192) {
          i += String.fromCharCode((s & 31) << 6 | o);
          continue;
        }
        var f = r[e++] & 63;
        if ((s & 240) == 224 ? s = (s & 15) << 12 | o << 6 | f : s = (s & 7) << 18 | o << 12 | f << 6 | r[e++] & 63, s < 65536)
          i += String.fromCharCode(s);
        else {
          var c = s - 65536;
          i += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
        }
      }
      return i;
    }, rt = (r, e) => r ? ze(h, r, e) : "", et = (r, e) => {
      e = g(e);
      var t = e === "std::string";
      E(r, {
        name: e,
        fromWireType(n) {
          var a = d[n >> 2], i = n + 4, s;
          if (t)
            for (var o = i, f = 0; f <= a; ++f) {
              var c = i + f;
              if (f == a || h[c] == 0) {
                var v = c - o, l = rt(o, v);
                s === void 0 ? s = l : (s += "\0", s += l), o = c + 1;
              }
            }
          else {
            for (var _ = new Array(a), f = 0; f < a; ++f)
              _[f] = String.fromCharCode(h[i + f]);
            s = _.join("");
          }
          return F(n), s;
        },
        toWireType(n, a) {
          a instanceof ArrayBuffer && (a = new Uint8Array(a));
          var i, s = typeof a == "string";
          s || a instanceof Uint8Array || a instanceof Uint8ClampedArray || a instanceof Int8Array || y("Cannot pass non-string to std::string"), t && s ? i = Qe(a) : i = a.length;
          var o = pr(4 + i + 1), f = o + 4;
          if (d[o >> 2] = i, t && s)
            Je(a, f, i + 1);
          else if (s)
            for (var c = 0; c < i; ++c) {
              var v = a.charCodeAt(c);
              v > 255 && (F(f), y("String has UTF-16 code units that do not fit in 8 bits")), h[f + c] = v;
            }
          else
            for (var c = 0; c < i; ++c)
              h[f + c] = a[c];
          return n !== null && n.push(F, o), o;
        },
        argPackAdvance: C,
        readValueFromPointer: er,
        destructorFunction(n) {
          F(n);
        }
      });
    }, Xr = typeof TextDecoder < "u" ? new TextDecoder("utf-16le") : void 0, tt = (r, e) => {
      for (var t = r, n = t >> 1, a = n + e / 2; !(n >= a) && L[n]; )
        ++n;
      if (t = n << 1, t - r > 32 && Xr)
        return Xr.decode(h.subarray(r, t));
      for (var i = "", s = 0; !(s >= e / 2); ++s) {
        var o = x[r + s * 2 >> 1];
        if (o == 0)
          break;
        i += String.fromCharCode(o);
      }
      return i;
    }, nt = (r, e, t) => {
      var n;
      if ((n = t) !== null && n !== void 0 || (t = 2147483647), t < 2)
        return 0;
      t -= 2;
      for (var a = e, i = t < r.length * 2 ? t / 2 : r.length, s = 0; s < i; ++s) {
        var o = r.charCodeAt(s);
        x[e >> 1] = o, e += 2;
      }
      return x[e >> 1] = 0, e - a;
    }, at = (r) => r.length * 2, it = (r, e) => {
      for (var t = 0, n = ""; !(t >= e / 4); ) {
        var a = D[r + t * 4 >> 2];
        if (a == 0)
          break;
        if (++t, a >= 65536) {
          var i = a - 65536;
          n += String.fromCharCode(55296 | i >> 10, 56320 | i & 1023);
        } else
          n += String.fromCharCode(a);
      }
      return n;
    }, ot = (r, e, t) => {
      var n;
      if ((n = t) !== null && n !== void 0 || (t = 2147483647), t < 4)
        return 0;
      for (var a = e, i = a + t - 4, s = 0; s < r.length; ++s) {
        var o = r.charCodeAt(s);
        if (o >= 55296 && o <= 57343) {
          var f = r.charCodeAt(++s);
          o = 65536 + ((o & 1023) << 10) | f & 1023;
        }
        if (D[e >> 2] = o, e += 4, e + 4 > i)
          break;
      }
      return D[e >> 2] = 0, e - a;
    }, st = (r) => {
      for (var e = 0, t = 0; t < r.length; ++t) {
        var n = r.charCodeAt(t);
        n >= 55296 && n <= 57343 && ++t, e += 4;
      }
      return e;
    }, ut = (r, e, t) => {
      t = g(t);
      var n, a, i, s;
      e === 2 ? (n = tt, a = nt, s = at, i = (o) => L[o >> 1]) : e === 4 && (n = it, a = ot, s = st, i = (o) => d[o >> 2]), E(r, {
        name: t,
        fromWireType: (o) => {
          for (var f = d[o >> 2], c, v = o + 4, l = 0; l <= f; ++l) {
            var _ = o + 4 + l * e;
            if (l == f || i(_) == 0) {
              var m = _ - v, S = n(v, m);
              c === void 0 ? c = S : (c += "\0", c += S), v = _ + e;
            }
          }
          return F(o), c;
        },
        toWireType: (o, f) => {
          typeof f != "string" && y(`Cannot pass non-string to C++ string type ${t}`);
          var c = s(f), v = pr(4 + c + e);
          return d[v >> 2] = c / e, a(f, v + 4, c + e), o !== null && o.push(F, v), v;
        },
        argPackAdvance: C,
        readValueFromPointer: er,
        destructorFunction(o) {
          F(o);
        }
      });
    }, ft = (r, e, t, n, a, i) => {
      rr[r] = {
        name: g(e),
        rawConstructor: Z(t, n),
        rawDestructor: Z(a, i),
        fields: []
      };
    }, ct = (r, e, t, n, a, i, s, o, f, c) => {
      rr[r].fields.push({
        fieldName: g(e),
        getterReturnType: t,
        getter: Z(n, a),
        getterContext: i,
        setterArgumentType: s,
        setter: Z(o, f),
        setterContext: c
      });
    }, vt = (r, e) => {
      e = g(e), E(r, {
        isVoid: !0,
        name: e,
        argPackAdvance: 0,
        fromWireType: () => {
        },
        toWireType: (t, n) => {
        }
      });
    }, _r = [], lt = (r, e, t, n) => (r = _r[r], e = j.toValue(e), r(null, e, t, n)), dt = {}, _t = (r) => {
      var e = dt[r];
      return e === void 0 ? g(r) : e;
    }, Zr = () => {
      if (typeof globalThis == "object")
        return globalThis;
      function r(e) {
        e.$$$embind_global$$$ = e;
        var t = typeof $$$embind_global$$$ == "object" && e.$$$embind_global$$$ == e;
        return t || delete e.$$$embind_global$$$, t;
      }
      if (typeof $$$embind_global$$$ == "object" || (typeof global == "object" && r(global) ? $$$embind_global$$$ = global : typeof self == "object" && r(self) && ($$$embind_global$$$ = self), typeof $$$embind_global$$$ == "object"))
        return $$$embind_global$$$;
      throw Error("unable to get global object.");
    }, pt = (r) => r === 0 ? j.toHandle(Zr()) : (r = _t(r), j.toHandle(Zr()[r])), ht = (r) => {
      var e = _r.length;
      return _r.push(r), e;
    }, gt = (r, e) => {
      for (var t = new Array(r), n = 0; n < r; ++n)
        t[n] = Hr(d[e + n * 4 >> 2], "parameter " + n);
      return t;
    }, mt = Reflect.construct, yt = (r, e, t) => {
      var n = [], a = r.toWireType(n, t);
      return n.length && (d[e >> 2] = j.toHandle(n)), a;
    }, bt = (r, e, t) => {
      var n = gt(r, e), a = n.shift();
      r--;
      var i = new Array(r), s = (f, c, v, l) => {
        for (var _ = 0, m = 0; m < r; ++m)
          i[m] = n[m].readValueFromPointer(l + _), _ += n[m].argPackAdvance;
        var S = t === 1 ? mt(c, i) : c.apply(f, i);
        return yt(a, v, S);
      }, o = `methodCaller<(${n.map((f) => f.name).join(", ")}) => ${a.name}>`;
      return ht(nr(o, s));
    }, wt = (r) => {
      r > 9 && (P[r + 1] += 1);
    }, Tt = (r) => {
      var e = j.toValue(r);
      vr(e), dr(r);
    }, $t = () => {
      Fr("");
    }, At = (r, e, t) => h.copyWithin(r, e, e + t), Et = () => 2147483648, Rt = (r) => {
      var e = z.buffer, t = (r - e.byteLength + 65535) / 65536;
      try {
        return z.grow(t), Er(), 1;
      } catch {
      }
    }, Ct = (r) => {
      var e = h.length;
      r >>>= 0;
      var t = Et();
      if (r > t)
        return !1;
      for (var n = (f, c) => f + (c - f % c) % c, a = 1; a <= 4; a *= 2) {
        var i = e * (1 + 0.2 / a);
        i = Math.min(i, r + 100663296);
        var s = Math.min(t, n(Math.max(r, i), 65536)), o = Rt(s);
        if (o)
          return !0;
      }
      return !1;
    }, Pt = (r) => r;
    Mr = u.InternalError = class extends Error {
      constructor(e) {
        super(e), this.name = "InternalError";
      }
    }, $e(), Dr = u.BindingError = class extends Error {
      constructor(e) {
        super(e), this.name = "BindingError";
      }
    }, Ce(), Nr = u.UnboundTypeError = Ne(Error, "UnboundTypeError");
    var Ft = {
      r: _e,
      q: pe,
      g: ge,
      d: me,
      k: ye,
      a: be,
      i: he,
      M: we,
      C: Te,
      H: Ee,
      G: Fe,
      K: Se,
      b: Ue,
      v: Ie,
      L: Ze,
      h: Ge,
      e: Ke,
      u: et,
      p: ut,
      w: ft,
      N: ct,
      I: vt,
      z: lt,
      P: dr,
      B: pt,
      A: bt,
      x: wt,
      Q: Tt,
      s: $t,
      F: At,
      E: Ct,
      y: It,
      c: Wt,
      l: jt,
      n: Mt,
      o: xt,
      f: kt,
      t: Vt,
      m: Ot,
      D: Ut,
      J: St,
      j: Dt,
      O: Pt
    }, p = de(), pr = u._malloc = (r) => (pr = u._malloc = p.T)(r), F = u._free = (r) => (F = u._free = p.U)(r), qr = (r) => (qr = p.W)(r), w = (r, e) => (w = p.X)(r, e), q = (r) => (q = p.Y)(r), T = () => (T = p.Z)(), $ = (r) => ($ = p._)(r), Gr = (r) => (Gr = p.$)(r), Kr = (r) => (Kr = p.aa)(r), Yr = (r, e, t) => (Yr = p.ba)(r, e, t), Jr = (r) => (Jr = p.ca)(r);
    function Wt(r, e) {
      var t = T();
      try {
        return b(r)(e);
      } catch (n) {
        if ($(t), n !== n + 0)
          throw n;
        w(1, 0);
      }
    }
    function kt(r, e) {
      var t = T();
      try {
        b(r)(e);
      } catch (n) {
        if ($(t), n !== n + 0)
          throw n;
        w(1, 0);
      }
    }
    function St(r, e, t, n, a, i) {
      var s = T();
      try {
        b(r)(e, t, n, a, i);
      } catch (o) {
        if ($(s), o !== o + 0)
          throw o;
        w(1, 0);
      }
    }
    function Ut(r, e, t, n, a) {
      var i = T();
      try {
        b(r)(e, t, n, a);
      } catch (s) {
        if ($(i), s !== s + 0)
          throw s;
        w(1, 0);
      }
    }
    function Mt(r, e, t, n) {
      var a = T();
      try {
        return b(r)(e, t, n);
      } catch (i) {
        if ($(a), i !== i + 0)
          throw i;
        w(1, 0);
      }
    }
    function It(r, e, t, n, a) {
      var i = T();
      try {
        return b(r)(e, t, n, a);
      } catch (s) {
        if ($(i), s !== s + 0)
          throw s;
        w(1, 0);
      }
    }
    function jt(r, e, t) {
      var n = T();
      try {
        return b(r)(e, t);
      } catch (a) {
        if ($(n), a !== a + 0)
          throw a;
        w(1, 0);
      }
    }
    function xt(r) {
      var e = T();
      try {
        b(r)();
      } catch (t) {
        if ($(e), t !== t + 0)
          throw t;
        w(1, 0);
      }
    }
    function Dt(r, e, t, n, a, i, s, o, f, c, v) {
      var l = T();
      try {
        b(r)(e, t, n, a, i, s, o, f, c, v);
      } catch (_) {
        if ($(l), _ !== _ + 0)
          throw _;
        w(1, 0);
      }
    }
    function Ot(r, e, t, n) {
      var a = T();
      try {
        b(r)(e, t, n);
      } catch (i) {
        if ($(a), i !== i + 0)
          throw i;
        w(1, 0);
      }
    }
    function Vt(r, e, t) {
      var n = T();
      try {
        b(r)(e, t);
      } catch (a) {
        if ($(n), a !== a + 0)
          throw a;
        w(1, 0);
      }
    }
    var ir;
    X = function r() {
      ir || Qr(), ir || (X = r);
    };
    function Qr() {
      if (U > 0 || (te(), U > 0))
        return;
      function r() {
        ir || (ir = !0, u.calledRun = !0, !Tr && (ne(), mr(u), u.onRuntimeInitialized && u.onRuntimeInitialized(), ae()));
      }
      u.setStatus ? (u.setStatus("Running..."), setTimeout(function() {
        setTimeout(function() {
          u.setStatus("");
        }, 1), r();
      }, 1)) : r();
    }
    if (u.preInit)
      for (typeof u.preInit == "function" && (u.preInit = [u.preInit]); u.preInit.length > 0; )
        u.preInit.pop()();
    return Qr(), Y.ready;
  };
})();
function Gt(W) {
  return Bt(
    gr,
    W
  );
}
function Kt(W) {
  return Nt(
    gr,
    W
  );
}
async function Yt(W, Y) {
  return Lt(
    gr,
    W,
    Y
  );
}
export {
  zt as barcodeFormats,
  rn as characterSets,
  en as defaultEncodeHints,
  tn as defaultWriterOptions,
  Gt as getZXingModule,
  nn as purgeZXingModule,
  Kt as setZXingModuleOverrides,
  Yt as writeBarcodeToImageFile,
  an as writeInputEccLevels
};
